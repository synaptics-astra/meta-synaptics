From aa1e16ab04d9d07a9e22a4204065bbcf679dfd9d Mon Sep 17 00:00:00 2001
From: Xiaomei Shang <xiaomei.shang@synaptics.com>
Date: Mon, 29 Apr 2024 13:17:39 +0800
Subject: [PATCH] add: build patch

copy command_line_flags.cc and command_line_flags.h from tensorflow-lite/tools
in order to remove the dependency on tensorflow-lite source code
https://github.com/synaptics-synap/tflite-vx-delegate/blob/syna-tf_V2.11.0-1/cmake/modules/Findtensorflow.cmake#L69

current solution is olny depend on tflite header files and shared library


---
 CMakeLists.txt                     |   3 +-
 cmake/modules/Findtensorflow.cmake |  15 +-
 command_line_flags.cc              | 334 +++++++++++++++++++++++++++++
 command_line_flags.h               | 175 +++++++++++++++
 vsi_npu_custom_op.cc               |   1 -
 5 files changed, 515 insertions(+), 13 deletions(-)
 create mode 100644 command_line_flags.cc
 create mode 100644 command_line_flags.h

diff --git a/CMakeLists.txt b/CMakeLists.txt
index b051b88..d86aa87 100644
--- a/CMakeLists.txt
+++ b/CMakeLists.txt
@@ -58,14 +58,13 @@ list(APPEND VX_DELEGATES_SRCS
   ${CMAKE_CURRENT_SOURCE_DIR}/op_map.cc
   ${CMAKE_CURRENT_SOURCE_DIR}/utils.cc
   ${CMAKE_CURRENT_SOURCE_DIR}/vx_delegate_adaptor.cc
+  ${CMAKE_CURRENT_SOURCE_DIR}/command_line_flags.cc
 )
 
 if(TFLITE_ENABLE_MULTI_DEVICE)
   ADD_DEFINITIONS(-DMULTI_DEVICE_FEATURE_MODE)
 endif()
 
-add_link_options($<$<CONFIG:RELEASE>:-s>)
-
 add_library(vx_delegate SHARED ${VX_DELEGATES_SRCS})
 
 list(APPEND VX_CUSTOM_OP_SRCS
diff --git a/cmake/modules/Findtensorflow.cmake b/cmake/modules/Findtensorflow.cmake
index 8b33c3e..2c582e7 100644
--- a/cmake/modules/Findtensorflow.cmake
+++ b/cmake/modules/Findtensorflow.cmake
@@ -27,13 +27,11 @@ if(EXISTS ${TF_SOURCES_DIR})
   set(tensorflow_SOURCE_DIR ${TF_SOURCES_DIR})
 
   set(TFLITE_INC
-    ${TFLITE_BINARY_DIR}/ruy
-    ${TFLITE_BINARY_DIR}/eigen
-    ${TFLITE_BINARY_DIR}/gemmlowp
-    ${TFLITE_BINARY_DIR}/abseil-cpp
-    ${TFLITE_BINARY_DIR}/flatbuffers/include
-    ${TFLITE_BINARY_DIR}/pthreadpool-source/include
-    ${TF_SOURCES_DIR}
+    ${EIGEN_INC_DIR}
+    ${GEMMLOWP_INC_DIR}
+    ${ABSEIL_SRC_DIR}
+    ${PTHREADPOOL_INC_DIR}
+    ${TF_INC_DIR}
   )
 
   add_library(TensorFlow::tensorflow-lite UNKNOWN IMPORTED)
@@ -66,6 +64,3 @@ endif()
 
 
 list(APPEND VX_DELEGATE_DEPENDENCIES TensorFlow::tensorflow-lite)
-list(APPEND VX_DELEGATES_SRCS ${TFLITE_SOURCE_DIR}/tools/command_line_flags.cc)
-list(APPEND VX_CUSTOM_OP_SRCS ${TFLITE_SOURCE_DIR}/delegates/external/external_delegate.cc)
-
diff --git a/command_line_flags.cc b/command_line_flags.cc
new file mode 100644
index 0000000..fccefd2
--- /dev/null
+++ b/command_line_flags.cc
@@ -0,0 +1,334 @@
+/* Copyright 2018 The TensorFlow Authors. All Rights Reserved.
+Licensed under the Apache License, Version 2.0 (the "License");
+you may not use this file except in compliance with the License.
+You may obtain a copy of the License at
+    http://www.apache.org/licenses/LICENSE-2.0
+Unless required by applicable law or agreed to in writing, software
+distributed under the License is distributed on an "AS IS" BASIS,
+WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+See the License for the specific language governing permissions and
+limitations under the License.
+==============================================================================*/
+
+// #include "tensorflow/lite/tools/command_line_flags.h"
+
+#include "command_line_flags.h"
+
+#include <algorithm>
+#include <cstring>
+#include <functional>
+#include <iomanip>
+#include <numeric>
+#include <sstream>
+#include <string>
+#include <unordered_map>
+#include <utility>
+#include <vector>
+
+#include "absl/strings/match.h"
+#include "tensorflow/lite/tools/logging.h"
+
+namespace tflite {
+namespace {
+
+template <typename T>
+std::string ToString(T val) {
+  std::ostringstream stream;
+  stream << val;
+  return stream.str();
+}
+
+template <>
+std::string ToString(bool val) {
+  return val ? "true" : "false";
+}
+
+template <>
+std::string ToString(const std::string& val) {
+  return val;
+}
+
+bool ParseFlag(const std::string& arg, int argv_position,
+               const std::string& flag, bool positional,
+               const std::function<bool(const std::string&, int argv_position)>&
+                   parse_func,
+               bool* value_parsing_ok) {
+  if (positional) {
+    *value_parsing_ok = parse_func(arg, argv_position);
+    return true;
+  }
+  *value_parsing_ok = true;
+  std::string flag_prefix = "--" + flag + "=";
+  if (!absl::StartsWith(arg, flag_prefix)) {
+    return false;
+  }
+  bool has_value = arg.size() >= flag_prefix.size();
+  *value_parsing_ok = has_value;
+  if (has_value) {
+    *value_parsing_ok =
+        parse_func(arg.substr(flag_prefix.size()), argv_position);
+  }
+  return true;
+}
+
+template <typename T>
+bool ParseFlag(const std::string& flag_value, int argv_position,
+               const std::function<void(const T&, int)>& hook) {
+  std::istringstream stream(flag_value);
+  T read_value;
+  stream >> read_value;
+  if (!stream.eof() && !stream.good()) {
+    return false;
+  }
+  hook(read_value, argv_position);
+  return true;
+}
+
+template <>
+bool ParseFlag(const std::string& flag_value, int argv_position,
+               const std::function<void(const bool&, int)>& hook) {
+  if (flag_value != "true" && flag_value != "false" && flag_value != "0" &&
+      flag_value != "1") {
+    return false;
+  }
+
+  hook(flag_value == "true" || flag_value == "1", argv_position);
+  return true;
+}
+
+template <typename T>
+bool ParseFlag(const std::string& flag_value, int argv_position,
+               const std::function<void(const std::string&, int)>& hook) {
+  hook(flag_value, argv_position);
+  return true;
+}
+}  // namespace
+
+#define CONSTRUCTOR_IMPLEMENTATION(flag_T, default_value_T, flag_enum_val)     \
+  Flag::Flag(const char* name,                                                 \
+             const std::function<void(const flag_T& /*flag_val*/,              \
+                                      int /*argv_position*/)>& hook,           \
+             default_value_T default_value, const std::string& usage_text,     \
+             FlagType flag_type)                                               \
+      : name_(name),                                                           \
+        type_(flag_enum_val),                                                  \
+        value_hook_([hook](const std::string& flag_value, int argv_position) { \
+          return ParseFlag<flag_T>(flag_value, argv_position, hook);           \
+        }),                                                                    \
+        default_for_display_(ToString<default_value_T>(default_value)),        \
+        usage_text_(usage_text),                                               \
+        flag_type_(flag_type) {}
+
+CONSTRUCTOR_IMPLEMENTATION(int32_t, int32_t, TYPE_INT32)
+CONSTRUCTOR_IMPLEMENTATION(int64_t, int64_t, TYPE_INT64)
+CONSTRUCTOR_IMPLEMENTATION(float, float, TYPE_FLOAT)
+CONSTRUCTOR_IMPLEMENTATION(bool, bool, TYPE_BOOL)
+CONSTRUCTOR_IMPLEMENTATION(std::string, const std::string&, TYPE_STRING)
+
+#undef CONSTRUCTOR_IMPLEMENTATION
+
+bool Flag::Parse(const std::string& arg, int argv_position,
+                 bool* value_parsing_ok) const {
+  return ParseFlag(
+      arg, argv_position, name_, flag_type_ == kPositional,
+      [&](const std::string& read_value, int argv_position) {
+        return value_hook_(read_value, argv_position);
+      },
+      value_parsing_ok);
+}
+
+std::string Flag::GetTypeName() const {
+  switch (type_) {
+    case TYPE_INT32:
+      return "int32";
+    case TYPE_INT64:
+      return "int64";
+    case TYPE_FLOAT:
+      return "float";
+    case TYPE_BOOL:
+      return "bool";
+    case TYPE_STRING:
+      return "string";
+  }
+
+  return "unknown";
+}
+
+/*static*/ bool Flags::Parse(int* argc, const char** argv,
+                             const std::vector<Flag>& flag_list) {
+  bool result = true;
+  std::vector<bool> unknown_argvs(*argc, true);
+  // Record the list of flags that have been processed. key is the flag's name
+  // and the value is the corresponding argv index if there's one, or -1 when
+  // the argv list doesn't contain this flag.
+  std::unordered_map<std::string, int> processed_flags;
+
+  // Stores indexes of flag_list in a sorted order.
+  std::vector<int> sorted_idx(flag_list.size());
+  std::iota(std::begin(sorted_idx), std::end(sorted_idx), 0);
+  std::sort(sorted_idx.begin(), sorted_idx.end(), [&flag_list](int a, int b) {
+    return flag_list[a].GetFlagType() < flag_list[b].GetFlagType();
+  });
+  int positional_count = 0;
+
+  for (int idx = 0; idx < sorted_idx.size(); ++idx) {
+    const Flag& flag = flag_list[sorted_idx[idx]];
+
+    const auto it = processed_flags.find(flag.name_);
+    if (it != processed_flags.end()) {
+#ifndef NDEBUG
+      // Only log this in debug builds.
+      TFLITE_LOG(WARN) << "Duplicate flags: " << flag.name_;
+#endif
+      if (it->second != -1) {
+        bool value_parsing_ok;
+        flag.Parse(argv[it->second], it->second, &value_parsing_ok);
+        if (!value_parsing_ok) {
+          TFLITE_LOG(ERROR) << "Failed to parse flag '" << flag.name_
+                            << "' against argv '" << argv[it->second] << "'";
+          result = false;
+        }
+        continue;
+      } else if (flag.flag_type_ == Flag::kRequired) {
+        TFLITE_LOG(ERROR) << "Required flag not provided: " << flag.name_;
+        // If the required flag isn't found, we immediately stop the whole flag
+        // parsing.
+        result = false;
+        break;
+      }
+    }
+
+    // Parses positional flags.
+    if (flag.flag_type_ == Flag::kPositional) {
+      if (++positional_count >= *argc) {
+        TFLITE_LOG(ERROR) << "Too few command line arguments.";
+        return false;
+      }
+      bool value_parsing_ok;
+      flag.Parse(argv[positional_count], positional_count, &value_parsing_ok);
+      if (!value_parsing_ok) {
+        TFLITE_LOG(ERROR) << "Failed to parse positional flag: " << flag.name_;
+        return false;
+      }
+      unknown_argvs[positional_count] = false;
+      processed_flags[flag.name_] = positional_count;
+      continue;
+    }
+
+    // Parse other flags.
+    bool was_found = false;
+    for (int i = positional_count + 1; i < *argc; ++i) {
+      if (!unknown_argvs[i]) continue;
+      bool value_parsing_ok;
+      was_found = flag.Parse(argv[i], i, &value_parsing_ok);
+      if (!value_parsing_ok) {
+        TFLITE_LOG(ERROR) << "Failed to parse flag '" << flag.name_
+                          << "' against argv '" << argv[i] << "'";
+        result = false;
+      }
+      if (was_found) {
+        unknown_argvs[i] = false;
+        processed_flags[flag.name_] = i;
+        break;
+      }
+    }
+
+    // If the flag is found from the argv (i.e. the flag name appears in argv),
+    // continue to the next flag parsing.
+    if (was_found) continue;
+
+    // The flag isn't found, do some bookkeeping work.
+    processed_flags[flag.name_] = -1;
+    if (flag.flag_type_ == Flag::kRequired) {
+      TFLITE_LOG(ERROR) << "Required flag not provided: " << flag.name_;
+      result = false;
+      // If the required flag isn't found, we immediately stop the whole flag
+      // parsing by breaking the outer-loop (i.e. the 'sorted_idx'-iteration
+      // loop).
+      break;
+    }
+  }
+
+  int dst = 1;  // Skip argv[0]
+  for (int i = 1; i < *argc; ++i) {
+    if (unknown_argvs[i]) {
+      argv[dst++] = argv[i];
+    }
+  }
+  *argc = dst;
+  return result && (*argc < 2 || std::strcmp(argv[1], "--help") != 0);
+}
+
+/*static*/ std::string Flags::Usage(const std::string& cmdline,
+                                    const std::vector<Flag>& flag_list) {
+  // Stores indexes of flag_list in a sorted order.
+  std::vector<int> sorted_idx(flag_list.size());
+  std::iota(std::begin(sorted_idx), std::end(sorted_idx), 0);
+  std::stable_sort(
+      sorted_idx.begin(), sorted_idx.end(), [&flag_list](int a, int b) {
+        return flag_list[a].GetFlagType() < flag_list[b].GetFlagType();
+      });
+  // Counts number of positional flags will be shown.
+  int positional_count = 0;
+  std::ostringstream usage_text;
+  usage_text << "usage: " << cmdline;
+  // Prints usage for positional flag.
+  for (int i = 0; i < sorted_idx.size(); ++i) {
+    const Flag& flag = flag_list[sorted_idx[i]];
+    if (flag.flag_type_ == Flag::kPositional) {
+      positional_count++;
+      usage_text << " <" << flag.name_ << ">";
+    } else {
+      usage_text << " <flags>";
+      break;
+    }
+  }
+  usage_text << "\n";
+
+  // Finds the max number of chars of the name column in the usage message.
+  int max_name_width = 0;
+  std::vector<std::string> name_column(flag_list.size());
+  for (int i = 0; i < sorted_idx.size(); ++i) {
+    const Flag& flag = flag_list[sorted_idx[i]];
+    if (flag.flag_type_ != Flag::kPositional) {
+      name_column[i] += "--";
+      name_column[i] += flag.name_;
+      name_column[i] += "=";
+      name_column[i] += flag.default_for_display_;
+    } else {
+      name_column[i] += flag.name_;
+    }
+    if (name_column[i].size() > max_name_width) {
+      max_name_width = name_column[i].size();
+    }
+  }
+
+  if (positional_count > 0) {
+    usage_text << "Where:\n";
+  }
+  for (int i = 0; i < sorted_idx.size(); ++i) {
+    const Flag& flag = flag_list[sorted_idx[i]];
+    if (i == positional_count) {
+      usage_text << "Flags:\n";
+    }
+    auto type_name = flag.GetTypeName();
+    usage_text << "\t";
+    usage_text << std::left << std::setw(max_name_width) << name_column[i];
+    usage_text << "\t" << type_name << "\t";
+    usage_text << (flag.flag_type_ != Flag::kOptional ? "required"
+                                                      : "optional");
+    usage_text << "\t" << flag.usage_text_ << "\n";
+  }
+  return usage_text.str();
+}
+
+/*static*/ std::string Flags::ArgsToString(int argc, const char** argv) {
+  std::string args;
+  for (int i = 1; i < argc; ++i) {
+    args.append(argv[i]);
+    if (i != argc - 1) args.append(" ");
+  }
+  return args;
+}
+
+}  // namespace tflite
diff --git a/command_line_flags.h b/command_line_flags.h
new file mode 100644
index 0000000..a853f55
--- /dev/null
+++ b/command_line_flags.h
@@ -0,0 +1,175 @@
+/* Copyright 2018 The TensorFlow Authors. All Rights Reserved.
+
+Licensed under the Apache License, Version 2.0 (the "License");
+you may not use this file except in compliance with the License.
+You may obtain a copy of the License at
+
+    http://www.apache.org/licenses/LICENSE-2.0
+
+Unless required by applicable law or agreed to in writing, software
+distributed under the License is distributed on an "AS IS" BASIS,
+WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+See the License for the specific language governing permissions and
+limitations under the License.
+==============================================================================*/
+
+#ifndef TENSORFLOW_LITE_TOOLS_COMMAND_LINE_FLAGS_H_
+#define TENSORFLOW_LITE_TOOLS_COMMAND_LINE_FLAGS_H_
+
+#include <functional>
+#include <string>
+#include <vector>
+
+namespace tflite {
+// A simple command-line argument parsing module.
+// Dependency free simplified port of core/util/command_line_flags.
+// This class is written for benchmarks and uses inefficient string
+// concatenation. This was written to avoid dependency on tensorflow/core/util
+// which transitively brings in a lot of other dependencies that are not
+// necessary for tflite benchmarking code.
+// The recommended way of using it is with local variables and an initializer
+// list of Flag objects, for example:
+//
+// int some_int = 10;
+// bool some_switch = false;
+// std::string some_name = "something";
+//
+// std::vector<tensorFlow::Flag> flag_list = {
+//   Flag::CreateFlag("some_int", &some_int, "an integer that affects X"),
+//   Flag::CreateFlag("some_switch", &some_switch, "a bool that affects Y"),
+//   Flag::CreateFlag("some_name", &some_name, "a string that affects Z")
+// };
+// // Get usage message before ParseFlags() to capture default values.
+// std::string usage = Flag::Usage(argv[0], flag_list);
+// bool parsed_values_ok = Flags::Parse(&argc, argv, flag_list);
+//
+// tensorflow::port::InitMain(usage.c_str(), &argc, &argv);
+// if (argc != 1 || !parsed_values_ok) {
+//    ...output usage and error message...
+// }
+//
+// The argc and argv values are adjusted by the Parse function so all that
+// remains is the program name (at argv[0]) and any unknown arguments fill the
+// rest of the array. This means you can check for flags that weren't understood
+// by seeing if argv is greater than 1.
+// The result indicates if there were any errors parsing the values that were
+// passed to the command-line switches. For example, --some_int=foo would return
+// false because the argument is expected to be an integer.
+//
+// NOTE: Unlike gflags-style libraries, this library is intended to be
+// used in the `main()` function of your binary. It does not handle
+// flag definitions that are scattered around the source code.
+
+// A description of a single command line flag, holding its name, type, usage
+// text, and a pointer to the corresponding variable.
+class Flag {
+ public:
+  enum FlagType {
+    kPositional = 0,
+    kRequired,
+    kOptional,
+  };
+
+  // The order of the positional flags is the same as they are added.
+  // Positional flags are supposed to be required.
+  template <typename T>
+  static Flag CreateFlag(const char* name, T* val, const char* usage,
+                         FlagType flag_type = kOptional) {
+    return Flag(
+        name, [val](const T& v) { *val = v; }, *val, usage, flag_type);
+  }
+
+// "flag_T" is same as "default_value_T" for trivial types, like int32, bool
+// etc. But when it's a complex type, "default_value_T" is generally a const
+// reference "flag_T".
+#define CONSTRUCTOR_WITH_ARGV_INDEX(flag_T, default_value_T)         \
+  Flag(const char* name,                                             \
+       const std::function<void(const flag_T& /*flag_val*/,          \
+                                int /*argv_position*/)>& hook,       \
+       default_value_T default_value, const std::string& usage_text, \
+       FlagType flag_type);
+
+#define CONSTRUCTOR_WITHOUT_ARGV_INDEX(flag_T, default_value_T)            \
+  Flag(const char* name, const std::function<void(const flag_T&)>& hook,   \
+       default_value_T default_value, const std::string& usage_text,       \
+       FlagType flag_type)                                                 \
+      : Flag(                                                              \
+            name, [hook](const flag_T& flag_val, int) { hook(flag_val); }, \
+            default_value, usage_text, flag_type) {}
+
+  CONSTRUCTOR_WITH_ARGV_INDEX(int32_t, int32_t)
+  CONSTRUCTOR_WITHOUT_ARGV_INDEX(int32_t, int32_t)
+
+  CONSTRUCTOR_WITH_ARGV_INDEX(int64_t, int64_t)
+  CONSTRUCTOR_WITHOUT_ARGV_INDEX(int64_t, int64_t)
+
+  CONSTRUCTOR_WITH_ARGV_INDEX(float, float)
+  CONSTRUCTOR_WITHOUT_ARGV_INDEX(float, float)
+
+  CONSTRUCTOR_WITH_ARGV_INDEX(bool, bool)
+  CONSTRUCTOR_WITHOUT_ARGV_INDEX(bool, bool)
+
+  CONSTRUCTOR_WITH_ARGV_INDEX(std::string, const std::string&)
+  CONSTRUCTOR_WITHOUT_ARGV_INDEX(std::string, const std::string&)
+
+#undef CONSTRUCTOR_WITH_ARGV_INDEX
+#undef CONSTRUCTOR_WITHOUT_ARGV_INDEX
+
+  FlagType GetFlagType() const { return flag_type_; }
+
+  std::string GetFlagName() const { return name_; }
+
+ private:
+  friend class Flags;
+
+  bool Parse(const std::string& arg, int argv_position,
+             bool* value_parsing_ok) const;
+
+  std::string name_;
+  enum {
+    TYPE_INT32,
+    TYPE_INT64,
+    TYPE_BOOL,
+    TYPE_STRING,
+    TYPE_FLOAT,
+  } type_;
+
+  std::string GetTypeName() const;
+
+  std::function<bool(const std::string& /*read_value*/, int /*argv_position*/)>
+      value_hook_;
+  std::string default_for_display_;
+
+  std::string usage_text_;
+  FlagType flag_type_;
+};
+
+class Flags {
+ public:
+  // Parse the command line represented by argv[0, ..., (*argc)-1] to find flag
+  // instances matching flags in flaglist[].  Update the variables associated
+  // with matching flags, and remove the matching arguments from (*argc, argv).
+  // Return true iff all recognized flag values were parsed correctly, and the
+  // first remaining argument is not "--help".
+  // Note:
+  // 1. when there are duplicate args in argv for the same flag, the flag value
+  // and the parse result will be based on the 1st arg.
+  // 2. when there are duplicate flags in flag_list (i.e. two flags having the
+  // same name), all of them will be checked against the arg list and the parse
+  // result will be false if any of the parsing fails.
+  // See *Duplicate* unit tests in command_line_flags_test.cc for the
+  // illustration of such behaviors.
+  static bool Parse(int* argc, const char** argv,
+                    const std::vector<Flag>& flag_list);
+
+  // Return a usage message with command line cmdline, and the
+  // usage_text strings in flag_list[].
+  static std::string Usage(const std::string& cmdline,
+                           const std::vector<Flag>& flag_list);
+
+  // Return a space separated string containing argv[1, ..., argc-1].
+  static std::string ArgsToString(int argc, const char** argv);
+};
+}  // namespace tflite
+
+#endif  // TENSORFLOW_LITE_TOOLS_COMMAND_LINE_FLAGS_H_
diff --git a/vsi_npu_custom_op.cc b/vsi_npu_custom_op.cc
index 71f7d21..ad991e7 100644
--- a/vsi_npu_custom_op.cc
+++ b/vsi_npu_custom_op.cc
@@ -23,7 +23,6 @@ limitations under the License.
 #include "tensorflow/lite/c/common.h"
 #include "tensorflow/lite/kernels/internal/optimized/optimized_ops.h"
 #include "tensorflow/lite/kernels/internal/reference/reference_ops.h"
-#include "tensorflow/lite/kernels/internal/spectrogram.h"
 #include "tensorflow/lite/kernels/internal/tensor.h"
 #include "tensorflow/lite/kernels/internal/tensor_ctypes.h"
 #include "tensorflow/lite/kernels/kernel_util.h"
-- 
2.17.1

